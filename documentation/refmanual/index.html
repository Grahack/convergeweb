<!--#include virtual="/header.inc" -->

<h1>The aim of this document</h1>

This document is the Converge reference manual.


<h2>Concrete syntax</h2>

Since the direct interaction with Converge is through its concrete syntax in the form of source code in a text editor, let us establish the general rules for representing Converge code. Converge is syntactically similar to Python. This means it relies on indentation to show code blocks rather than using curly brackets <code>{ ... }</code> or <code>begin ... end</code> keywords. All indentation in Converge <em>must</em> be in the form of tabs; no other form of whitespace is acceptable.

<p>Note that due to deficiencies in HTML, all examples in this document are written using spaces instead of tabs as indentation. This means if you cut and paste code examples from this document you will need to replace the spaces at the beginning of a line with tabs.


<hr>


<h2>Hello world!</h2>

Let's start with the obvious <code>Hello world!</code> program:

<pre class="indented-code">
import Sys

func main():
    Sys.println("Hello world!")
</pre>

As expected, when this program is run it prints out <code>Hello world!</code>.

<p>Note how the body of the <code>main</code> function is indented from its <code>func main():</code> definition. The name of this function is also significant. When a program is run, Converge looks for a function called <code>main</code> and executes that function. If no such function exists, an exception is thrown.


<hr>


<h2>Compiling and linking</h2>

If the code fragment from the previous section is placed into a file <code>hello.cv</code>, it can be compiled and linked as follows:

<pre class="indented-code">
converge convergec -o hello.cvb hello.cv
converge convergel -o hello hello.cvb
</pre>

<code>converegec</code> is the name of the Converge compiler; <code>convergel</code> is the name of the Converge linker. Both are written in Converge itself, hence the need to invoke the Converge virtual machine to execute them.

<p>The linked program can then be run as follows:

<pre class="indented-code">
converge hello
</pre>


<h3>The Converge compiler</h3>

<p><code>convergec</code> produces <code>.cvb</code> files from <code>.cv</code> source files. Each <code>.cvb</code> file represents a single module. <code>convergec</code> accepts the following command-line parameters:

<pre class="indented-code">
convergec [-I &lt;directory&gt;] -o &lt;output&gt; &lt;input&gt;
</pre>

The <code>-I</code> switch specifies a directory to be included in the import path. Multiple <code>-I</code> switches can be specified; the directories listed will be searched in the order they are defined.


<h3>The Converge linker</h3>

<code>convergel</code> has two related functions. It can combine one or more <code>.cvb</file> and <code>.cvl</code> files into a Converge executable. It can also combine one or more <code>.cvb</file> files into a Converge library (<code>.cvl</code>) file.



<h3>Creating a Converge executable</h3>

<p><code>convergel</code> can combine one or more <code>.cvb</code> files into a converge executable. In this case <code>convergel</code> can be invoked thus:

<pre class="indented-code">
convergel -o &lt;output&gt; &lt;input&gt; [... &lt;input&gt;]
</pre>

The first input file must be a <code>.cvb</code> file; it is known as the <em>main module</em>. When the executable is run, the main module is searched for an function called <code>main</code> which is then executed. During linking, the main module's dependencies must be listed in the form of <code>.cvb</code> or <code>.cvl</code> files on the command line <em>after</em> the main module has been listed. These subsequent files must contain all the files which the main module and its dependencies import.

<p>As a trivial example, imagine we have a file <code>hello.cv</code>:

<pre class="indented-code">
import Sys
import World

func main():
    Sys.println("Hello " + World.world() + "!")
</pre>

and a second file <code>world.cv</code>:

<pre class="indented-code">
func world():
    return "world"
</pre>

then the following sequence would be needed to produce a functioning executable:

<pre class="indented-code">
converge convergec -o hello.cvb hello.cv
converge convergec -o world.cvb world.cv
converge convergel -o hello hello.cvb world.cvb
</pre>



<h3>Creating a Converge library</h3>

<p><code>convergel</code> can combine one or more <code>.cvb</code> files into a <code>.cvl</code> library. This is a simple convenience to prevent large quantities of <code>.cvb</code> files cluttering up a file system.

<pre class="indented-code">
convergel -l -o &lt;output.cvl&gt; &lt;input&gt; [... &lt;input&gt;]
</pre>


<hr>


<h2>Classes and functions</h2>

We have already seen a simple example of a function. A simple example of a class is as follows:

<pre class="indented-code">
class Animal:
    func init(name):
        self.name := name

    func get_name():
        return self.name

    func set_name(name):
        self.name := name
</pre>

Instances of the class can be created by instantiating the class <code>Animal()</code>. Objects can have methods called, and attributes assigned e.g.:

<pre class="indented-code">
fido := Animal()
fido.set_name("Fido")
Sys.println(fido.get_name())
</pre>

Functions within a class are slightly different to normal top-level functions; when they are extracted from an object they are <em>bound</em> to that object. The distinguished variable <code>self</code> is automatically assigned to the bound object. In all other respects bound and unbound functions are identical.


<h3>Function arguments</h3>

Functions can accept zero or more arguments in the standard way. The general form of a function is thus:

<p><code class="indented-code">
func m(a<sub>i</sub>, ..., a<sub>n</sub>, a<sub>j</sub> := &lt;<em>default value</em>&gt<sub>j</sub>;, ... a<sub>m</sub> := &lt;<em>default value</em>&gt<sub>m</sub>, *v)
</code>

<p>where <em>i</em>, <em>j</em> &gt;= 0 and <code>v</code> is optional. Put another way, this means that (optionally) normal arguments are (optionally) followed by arguments with default values and (optionally) completed by a final 'var args' variable.

<p>The caller of a function must specify values for all normal arguments. Arguments with default values for which no value is specified by the caller will have their default value evaluated and assigned to that arg. All remaining arguments are put into a list and assigned to <code>v</code>.

<p>For example a <code>printf</code> like function would be specified as follows:

<pre class="indented-code">
func printf(format, *var_args):
    ...
</pre>

An <code>fprintf</code> style function which defaults to using standard out might look as follows:

<pre class="indented-code">
func fprintf(format, stream := Sys.stdout, *var_args):
    ...
</pre>

Note that default values are evaluated each time a value is not passed to a particular argument. This is substantially different than the mechanism found in Python.

<p>Note that Converge has no concept of function overloading based on e.g. function arity.


<h3>Lexical scoping</h3>

Converge is lexically scoped. The following program will thus print <code>0</code> then <code>1</code> then <code>1</code>.

<pre class="indented-code">
func main():
    x := 0
    Sys.println(x)
    func f2():
        Sys.println(x)
    x := 1
    f2()
    Sys.println(x)
</pre>

Assignment of a variable in a block causes that variable to be made local to the block. The following program will thus print <code>0</code> then <code>0</code> then <code>0</code>.

<pre class="indented-code">
func main():
    x := 0
    Sys.println(x)
    func f2():
        x := 1
    Sys.println(x)
    f2()
    Sys.println(x)
</pre>

In order to assign to a variable in a higher block, the <code>nonlocal</code> statement at the beginning of a function punches a hole up to an appropriate layer. The following program will thus print <code>0</code> then <code>0</code> then <code>1</code>.

<pre class="indented-code">
func main():
    x := 0
    Sys.println(x)
    func f2():
        nonlocal x
        x := 1
    Sys.println(x)
    f2()
    Sys.println(x)
</pre>

Note that class elements are deliberately excluded from the standard scoping mechanism so that the following is invalid:

<pre class="indented-code">
class Dog(Animal):
    type := "Dog"

    func get_type():
        return type
</pre>

Class elements <em>must</em> be referenced via the <code>self</code> variable:

<pre class="indented-code">
class Dog(Animal):
    type := "Dog"

    func get_type():
        return self.type
</pre>


<hr>


<h2>Modules</h2>

The conventional structure of a Converge module is imports followed by constant definitions, classes and functions. As in Python, all parts of a module are <em>executed</em> when it is imported. Thus ordering of elements within the file is often important.

<p>For example whilst the following module is correct:

<pre class="indented-code">
class Animal:
    ...

class Dog(Animal):
    ...
</pre>

reversing the two classes would be incorrect because the creation of <code>Dog</code> would attempt to access the <code>Animal</code> variable before it has had a class assigned to it.

<p>However notice that it is only at the top-level that the ordering of elements is important. For example the following module is perfectly valid because by the time the <code>new_dog</code> function can be called lexical scoping will have ensured that <code>Dog</code> will have been assigned a value:

<pre class="indented-code">
func new_dog():
    return Dog()

class Animal:
    ...

class Dog(Animal):
    ...
</pre>


<hr>


<h2>Packages and importing</h2>

Converge programs are often organized into packages. Packages are directories which are collections of modules and sub-packages. Packages are identified by the existence of a <code>init.cv</code> file which must currently be empty. Packages can be nested to an arbitrary depth.


<h3>Importing modules and elements</h3>

The <code>import</code> statement imports an element into a modules namespace. By default the imported element is assigned to a variable which has the name of the final part of the <code>import</code> statement e.g. <code>import A.B.C</code> will bring into existence a variable <code>C</code> and assigns to it the value of the element <code>A.B.C</code>. This behaviour can be altered by using the <code>as <em>X</em></code> suffix. e.g. <code>import A.B.C as D</code> will bring into existence a variable <code>D</code> and assigns to it the value of the element <code>A.B.C</code>.

<p>Imports do not have to refer to a module; they can refer to an element within it. For example given the following structure:

<pre class="indented-code">
P/
    init.cv
    M1.cv
    SP/
        init.cv
        M2.cv
</pre>

and assuming that <code>M1</code> contains a class <code>C</code> then <code>M2</code> can validly use any or all of the following imports:

<pre class="indented-code">
import P
import P.M1
import P.M1.C
</pre>


<hr>


<h2>Standard types</h2>

Converge provides standard types such as lists, dictionaries, sets and strings:

<pre class="indented-code">
list := [1, 2, 3]
set := Set{3, 2, 1}
dict := Dict{"a" : 1, "c" : 3, "b" : 2}
str := "123"
</pre>


<h3>Lists</h3>

Lists support the full <em>slice notation</em>:

<pre class="indented-code">
list := [1, 2, 3, 4]
Sys.println(list[1])      // prints 1
Sys.println(list[0 : 2])  // prints [1, 2]
Sys.println(list[-1])     // prints 4
Sys.println(list[1 : -1]) // prints [2, 3]
list[3] := 10
Sys.println(list[-2])     // prints 10
list[1 : -1] := [5, 6, 7]
Sys.println(list)         // prints[1, 5, 6, 7, 4]
</pre>

Indexes start from zero. Negative indexes count <em>n</em> elements from the end of the list.

Important functions in lists:

<p><table cellpadding = "5px">
    <tr>
        <td>
            <code>append(o)</code>
        </td>
        <td>
            Appends the object <code>o</code> to the end of the list. Returns null.
        </td>
    </tr>
    <tr>
        <td>
            <code>contains(o)</code>
        </td>
        <td>
            Succeeds if the list contains an element equal to <code>0</code>; fails otherwise.
        </td>
    </tr>
    <tr>
        <td>
            <code>extend(l)</code>
        </td>
        <td>
            Concatenates the self list with the list <code>l</code>. Returns null.
        </td>
    </tr>
    <tr>
        <td>
            <code>del(p)</code>
        </td>
        <td>
            Deletes the item at position <code>p</code>. Returns null.
        </td>
    </tr>
    <tr>
        <td>
            <code>del_slice(p1, p2)</code>
        </td>
        <td>
            Deletes the slice between positions <code>p2</code> and <code>p2</code>. Returns null.
        </td>
    </tr>
    <tr>
        <td>
            <code>index(o)</code>
        </td>
        <td>
            Generates all index positions of <code>o</code>. Fails when all such positions have been generated.
        </td>
    </tr>
    <tr>
        <td>
            <code>iterate()</code>
        </td>
        <td>
            Generate all elements of the list in sequence.
        </td>
    </tr>
    <tr>
        <td>
            <code>len()</code>
        </td>
        <td>
            Returns the number of elements in the list.
        </td>
    </tr>
    <tr>
        <td>
            <code>riterate()</code>
        </td>
        <td>
            Generate all elements of the list in reverse sequence (i.e. starts at the end of the list and works backwards).
        </td>
    </tr>
</table>


<h3>Sets</h3>

Sets do not support the slice notation. Important functions in sets:

<p><table cellpadding = "5px">
    <tr>
        <td>
            <code>add(o)</code>
        </td>
        <td>
            Adds the object <code>o</code> to the set. If an element equal to <code>o</code> already exists within the set, <code>o</code> is ignored.
        </td>
    </tr>
       <tr>
        <td>
            <code>complement(s)</code>
        </td>
        <td>
            Returns the set complement of the current set &cap; <code>s</code>.
        </td>
    </tr>
    <tr>
        <td>
            <code>contains(o)</code>
        </td>
        <td>
            Succeeds if the sets contains an element equal to <code>0</code>; fails otherwise.
        </td>
    </tr>
    <tr>
        <td>
            <code>iterate()</code>
        </td>
        <td>
            Generate all elements of the set.
        </td>
    </tr>
    <tr>
        <td>
            <code>len()</code>
        </td>
        <td>
            Returns the number of elements in the set.
        </td>
    </tr>
       <tr>
        <td>
            <code>union(s)</code>
        </td>
        <td>
            Returns the set union of the current set &cup; <code>s</code>.
        </td>
    </tr>
</table>


<h3>Dictionaries</h3>

Dictionaries support some of the slice notation:

<pre class="indented-code">
dict := Dict{"a" : 1, "c" : 3, "b" : 2}
Sys.println(dict["a"])    // prints 1
dict["b"] := 10
Sys.println(dict["b"])    // prints 10
</pre>

Important functions in dictionaries:

<p><table cellpadding = "5px">
    <tr>
        <td>
            <code>contains(o)</code>
        </td>
        <td>
            Succeeds if the dictionary contains an element equal to <code>0</code>; fails otherwise.
        </td>
    </tr>
    <tr>
        <td>
            <code>iterate()</code>
        </td>
        <td>
            Generate all elements of the dictionary.
        </td>
    </tr>
    <tr>
        <td>
            <code>keys()</code>
        </td>
        <td>
            Returns a set containing all keys in the dictionary.
        </td>
    </tr>
    <tr>
        <td>
            <code>len()</code>
        </td>
        <td>
            Returns the number of elements in the dictionary.
        </td>
    </tr>
</table>



<h3>Strings</h3>

Converge strings are immutable and thus only support the lookup aspects of the slice notation:

<pre class="indented-code">
str := "1234"
Sys.println(str[1])      // prints "1"
Sys.println(str[0 : 2])  // prints "12"
Sys.println(str[-1])     // prints "4"
Sys.println(str[1 : -1]) // prints "23"
</pre>

Important functions in strings:

<p><table cellpadding = "5px">
    <tr>
        <td>
            <code>ascii_val(i := 0)</code>
        </td>
        <td>
            Returns the ascii_val of the character at position <code>i</code>, which defaults to <code>0</code>.
        </td>
    </tr>
    <tr>
        <td>
            <code>contains(s)</code>
        </td>
        <td>
            Succeeds if the string contains a substring <code>s</code>; fails otherwise.
        </td>
    </tr>
    <tr>
        <td>
            <code>index(s)</code>
        </td>
        <td>
            Generates all index positions of the substring <code>s</code>. Fails when all such positions have been generated.
        </td>
    </tr>
    <tr>
        <td>
            <code>iterate()</code>
        </td>
        <td>
            Generate all characters of the string in sequence.
        </td>
    </tr>
    <tr>
        <td>
            <code>len()</code>
        </td>
        <td>
            Returns the length of the string.
        </td>
    </tr>
    <tr>
        <td>
            <code>lower_case()</code>
        </td>
        <td>
            Returns a new string with all characters of the current string lower cased.
        </td>
    </tr>
    <tr>
        <td>
            <code>prefixed_by(s, i := 0)</code>
        </td>
        <td>
            Succeeds if the string has the whole of <code>s</code> as a prefix. The prefix position defaults to <code>0</code>.
        </td>
    </tr>
    <tr>
        <td>
            <code>upper_case()</code>
        </td>
        <td>
            Returns a new string with all characters of the current string upper cased.
        </td>
    </tr>
</table>


<h3>Integers</h3>

Converge integers are immutable. Important functions in integers:

<p><table cellpadding = "5px">
    <tr>
        <td>
            <code>upto(i, step := 1)</code>
        </td>
        <td>
            Generates all integer values from the integer upto but excluding <code>i</code> in increments of <code>step</code>.
        </td>
    </tr>
</table>


<hr>


<h2>Expressions</h2>

Converge is an expression based language based on Icon. Much of what is written about Icon is relevant to Converge. e.g. <a href="http://www.cs.arizona.edu/icon/docs/ipd266.htm">Ralph Griswold's introduction to Icon</a> is a very useful introduction.

<p>As has been seen earlier in the document, simple statements work in Converge much as one would expect. This section mostly documents deviations from the expected norm.


<h3>Assignment</h3>

Assignment is achieved via the <code>:=</code> operator to differentiate it from the equality operator <code>==</code>. Assignment returns the value of its right hand side. The following fragment prints <code>10</code>:

<pre class="indented-code">
Sys.println(i := 10)
</pre>

Syntactic sugar is available for addition <code>+=</code>, multiplication <code>*=</code> and division <code>/=</code> e.g.:

<pre class="indented-code">
i += 2
</pre>

The above is pure syntactic sugar for:

<pre class="indented-code">
i := i + 2
</pre>

Since assignment is an expression, assignments can be chained. The following fragment assigns <code>10</code> to both <code>x</code> and <code>y</code>:

<pre class="indented-code">
x := y := 10
</pre>

Assignment can be used to <emph>unpack</emph> sequence types. The following fragment prints <code>10</code> then <code>20</code>:

<pre class="indented-code">
x, y := [10, 20]
Sys.println(x)
Sys.println(y)
</pre>

The number of unpacking variables must equal exactly the size of the list being unpacked.


<h3>Success and failure</h3>

Converge does not have built-in boolean logic, since it provides alternative ways of achieving the expected observable behaviour of boolean logic.

<p>Expressions in Converge can <em>succeed</em> or <em>fail</em>. When an expression succeeds it produces a value; when it fails, various outcomes are possible. A simple example of an expression that succeeds is:

<pre class="indented-code">
x := 5 < 10
</pre>

This is in fact two expressions. Firstly the expression <code>5 < 10</code> succeeds and produces the value 10. The assignment of <code>10</code> to <code>x</code> succeeds and similarly produces the value <code>10</code>. In the presence of an if statement the following results in the expected behaviour, printing <code>Correct</code>:

<pre class="indented-code">
if 5 < 10 then:
    Sys.println("Correct")
else:
    Sys.println("Should never get here")
</pre>

If the expression in the <code>if</code> fails then the following fragment similarly produces the expected behaviour:

<pre class="indented-code">
if 10 < 5 then:
    Sys.println("Should never get here.")
else:
    Sys.println("Correct.")
</pre>

Essentially, the comparison <code>10 < 5</code> fails, which causes control to branch immediately to the <code>else</code> branch of the <code>if</code> statement.


<h3>Generators</h3>

Expressions in Converge can sometimes generate multiple values. In such a case, the failure of an expression is not necessarily immediately; instead the generator can be resumed to see if the new value it produces causes the expression to succeed. When all of a generators values are exhausted with no match, then the overall expression fails.

<p>The following fragment will assign the first number wholly divisible by <code>2</code> to <code>f</code>:

<pre class="indented-code">
l := [1, 3, 5, 8]
f := (x := l.iterate() & x % 2 == 0 & x)
</pre>

The <code>iterate</code> function of a list generates all the elements of a list in order. The first value it generates in the above example is <code>1</code> which is assigned to <code>x</code>. The ampersand <code>&amp;</code> operator <em>conjunction</em> is similar to 'and' - it means that all parts of the conjunction must succeed in order for the conjunction to succeed. If the conjunction succeeds, the value of the last part of the conjunction is returned. So the next step in the computation is to test <code>1 % 2 == 0</code> which fails. This causes control to backtrack to the last generator - the <code>iterate</code> generator, which produces another value and assigns it to <code>x</code>. This sequence repeats until eventually <code>8</code> is assigned to <code>x</code>. Since <code>8 % 2 == 0</code>, the conjunction can attempt to move to its next part, which is simply <code>x</code> which succeeds and causes <code>8</code> to be the result of the conjunction. <code>8</code> is thus assigned to <code>f</code>. This style of evaluation is known as <em>goal-directed evaluation</em>.

<p>It is important to note that control does not back up to arbitrary levels; in fact, backtracking is limited to <em>bound</em> expressions. For example, the condition of an <code>if</code> statement is a bound expression, so the failure of the condition does not cause control to escape back beyond the <code>if</code> statement. Significantly, each separate line in a source file is automatically a bound expression, so if the expression on one line fails, control does not backtrack to previous lines.

<p>Generators can be explicitly exhausted using the <code>for</code> statement. The following fragment prints all elements in the list <code>l</code>:

<pre class="indented-code">
l := [1, 3, 5, 8]
for e := l.iterate():
    Sys.println(e)
</pre>

Generators produce values (rather than simply <code>return</code>'ing a value) via the <code>yield</code> expression. For example the following function will generate all values from <code>m</code> up to but excluding <code>n</code>:

<pre class="indented-code">
func range(m, n):
    while m < n:
        yield m
        m += 1
</pre>


<h3>Alternation</h3>

In the previous section, conjunction was shown to be similar to the standard concept of <em>and</em>. Alternation is often used to emulate the behaviour of <em>or</em> e.g.:

<pre class="indented-code">
if i < j | i > 100:
    ...
</pre>

However alternation is in fact a special kind of generator which is more obviously shown in the following example which prints <code>1</code> then <code>2</code>:

<pre class="indented-code">
for i := 1 | 2:
    Sys.println(i)
</pre>


<h3>Precedence</h3>

Precedence within Converge is intended to be as simple as possible whilst still respecting the standard precedence rules inherited from mathematics. In general, everything in Converge groups from left to right.


<hr>


<h2>Control structures</h2>

Converge contains a standard complement of control structures.

<h3>The <code>if</code> control structure</h3>

<pre class="indented-code">
if <em>&lt;condition&gt;</em> then:
    ...
elif <em>&lt;condition&gt;</em> then:
    ...
...
else:
    ...
</pre>

Zero or more <code>elif</code> blocks can be specified. A maximum of one <code>else</code> block can be specified.

<p>If <em>condition</em> evaluates to <code>fail</code>, the condition itself itself is considered to fail. Note that this is substantially different than Icon's semantics.


<h3>The <code>for</code> control structure</h3>

<code>for</code> evaluates <code><em>expression</em></code> and loops until its values are exhausted. If the loop terminates naturally through the exhaustion of <code><em>expression</em></code>, the optional <code>exhausted</code> block is executed. If the loop is terminated through a <code>break</code> command, the optional <code>broken</code> block is executed. Both <code>exhausted</code> and <code>broken</code> blocks may optionally be specified on a <code>for</code> structure.

<pre class="indented-code">
for <em>&lt;expression&gt;</em>:
    ...
exhausted:
    ...
broken:
    ...
</pre>


<h3>The <code>while</code> control structure</h3>

<code>while</code> repeatedly evaluates <code><em>expression</em></code> until it fails. If the loop terminates naturally through <code><em>expression</em></code> failing, the optional <code>exhausted</code> block is executed. If the loop is terminated through a <code>break</code> command, the optional <code>broken</code> block is executed. Both <code>exhausted</code> and <code>broken</code> blocks may be specified on a <code>while</code> structure.

<pre class="indented-code">
while <em>&lt;expression&gt;</em>:
    ...
exhausted:
    ...
broken:
    ...
</pre>

Note that <code>while</code> differs from <code>for</code> in that <code><em>expression</em></code> is reevaluated on each loop. This means that the following fragment will loop infinitely printing <code>1</code>:

<pre class="indented-code">
l := [1, 2, 3, 4]
while i := l.iterate():
    Sys.println(i)
</pre>

since the <code>iterate</code> generator will be recreated anew on each loop which is probably not what was intended.


<h3><code>break</code> and <code>continue</code></h3>

<code>break</code> causes the innermost loop to be terminated immediately. <code>continue</code> causes the innermost loop to attempt its next iteration immediately.

<p>It is illegal to use <code>break</code> or <code>continue</code> outside of loops.


<h3><code>try</code> ... <code>catch</code></h3>

Evaluate a block, and catch exceptions that occur during its evaluation:

<pre class="indented-code">
try:
    ...
catch <em>&lt;Exception<sub>1</sub>&gt;</em> to <em>&lt;v<sub>1</sub>&gt;</em>:
    ...
catch to <em>&lt;v<sub>n</sub>&gt;</em>:
    ...
</pre>

One or more <code>catch</code>'s must be present. Zero or more <code>catch</code>'s catching specific exceptions may be specified. The final <code>catch</code> may optionally not catch a specific exception at which point it will catch all exceptions that occur.



<hr>

<h2>Standard modules</h2>

<h4>The <code>Builtins</code> module</h3>

This module provides access to the builtin Converge types via the following slots:

<p><table cellpadding = "5px">
    <tr>
        <td>
            <code>Class</code>
        </td>
        <td>
            The standard class <code>Class</code>.
        </td>
    </tr>
    <tr>
        <td>
            <code>Dict</code>
        </td>
        <td>
            The standard class <code>Dict</code>.
        </td>
    </tr>
    <tr>
        <td>
            <code>Int</code>
        </td>
        <td>
            The standard class <code>Int</code>.
        </td>
    </tr>
    <tr>
        <td>
            <code>List</code>
        </td>
        <td>
            The standard class <code>List</code>.
        </td>
    </tr>
    <tr>
        <td>
            <code>Object</code>
        </td>
        <td>
            The standard class <code>Object</code>.
        </td>
    </tr>
    <tr>
        <td>
            <code>Set</code>
        </td>
        <td>
            The standard class <code>Set</code>.
        </td>
    </tr>
    <tr>
        <td>
            <code>String</code>
        </td>
        <td>
            The standard class <code>String</code>.
        </td>
    </tr>
</table>



<h3>The <code>File</code> module</h3>

Important functions and classes in the <code>File</code> module are as follows:

<p><table cellpadding = "5px">
    <tr>
        <td>
            <code>canon_path(path)</code>
        </td>
        <td>
            Returns the fully canonicalized version of <code>path</code>. The exact effects are platform dependent.
        </td>
    </tr>
    <tr>
        <td>
            <code>dir_entries(path)</code>
        </td>
        <td>
            Returns a list of leaf names for all entries in the directory <code>path</code>.
        </td>
    </tr>
    <tr>
        <td>
            <code>exists(path)</code>
        </td>
        <td>
            Succeeds if <code>path</code> exists.
        </td>
    </tr>
    <tr>
        <td>
            <code>is_dir(path)</code>
        </td>
        <td>
            Succeeds if <code>path</code> is a directory. Notice that mere failure - as opposed to an exception being generated - does not necessarily imply that <code>path</code> exists but is not a directory [this behaviour is platform dependent].
        </td>
    </tr>
    <tr>
        <td>
            <code>join_names(*names)</code>
        </td>
        <td>
            Concatenates the entries of <code>dirs</code> into a path. This thus reverses the effects of <code>split_dirs</code> or <code>split_leaf</code>.
        </td>
    </tr>
    <tr>
        <td>
            <code>join_ext(path, ext)</code>
        </td>
        <td>
            Joins filename extension <code>ext</code> to the path <code>path</code>. If <code>ext</code> is empty, <code>path</code> is returned. This reverses the effect of <code>split_ext</code>.
        </td>
    </tr>
    <tr>
        <td>
            <code>open(path, mode)</code>
        </td>
        <td>
            Returns a file object representing the file <code>path</code>. <code>mode</code> should be <code>r</code> for read-only or <code>w</code> for write-only.
        </td>
    </tr>
    <tr>
        <td>
            <code>split_dirs(path)</code>
        </td>
        <td>
            Returns a list representing all the directories and the leaf name of <code>path</code>. The separator between the directories and leaf name is not present in the output. e.g. <code>split_dirs("/a/b/c")</code> returns <code>["a", "b", "c"]</code>.
        </td>
    </tr>
    <tr>
        <td>
            <code>split_ext(path)</code>
        </td>
        <td>
            Returns a list of length two <code>[<em>&lt;path's directory plus leaf name&gt;</em>, <em>&lt;path's file extension&gt;</em>]</code>. The file name extension separator is not present in either component. e.g. <code>split_ext("/a/b/c.d")</code> returns <code>["/a/b/c", "d"]</code>.
        </td>
    </tr>
    <tr>
        <td>
            <code>split_leaf(path)</code>
        </td>
        <td>
            Returns a list of length two <code>[<em>&lt;path's directory&gt;</em>, <em>&lt;path's leaf name&gt;</em>]</code>. The separator between the directory and leaf name is not present in either component. e.g. <code>split_leaf("/a/b/c")</code> returns <code>["/a/b", "c"]</code>.
        </td>
    </tr>
</table>

<p>File objects support the following methods:

<p><table cellpadding = "5px">
    <tr>
        <td>
            <code>close</code>
        </td>
        <td>
            Closes the file. Note that although the file will be closed when the file object is garbage collected, it is often good manners (and the release of a burden on the OS) to close files once they are finished with.
        </td>
    </tr>
    <tr>
        <td>
            <code>read(size := null)</code>
        </td>
        <td>
            Reads <code>size</code> bytes from the file. If <code>size</code> is <code>null</code>, the full contents of the file are returned.
        </td>
    </tr>
    <tr>
        <td>
            <code>read_line()</code>
        </td>
        <td>
            Reads a line from the file.
        </td>
    </tr>
    <tr>
        <td>
            <code>write(s)</code>
        </td>
        <td>
            Writes the string <code>s</code> to the file.
        </td>
    </tr>
</table>


<h3>The <code>Maths</code> module</h3>

Important functions and classes in the <code>Maths</code> module are as follows:

<p><table cellpadding = "5px">
    <tr>
        <td>
            <code>max(*objs)</code>
        </td>
        <td>
            Returns the object with the highest value in <code>objs</code>
        </td>
    </tr>
    <tr>
        <td>
            <code>min(*objs)</code>
        </td>
        <td>
            Returns the object with the lowest value in <code>objs</code>
        </td>
    </tr>
</table>


<h3>The <code>OS</code> module</h3>

Important functions and classes in the <code>OS</code> module are as follows:

<p><table cellpadding = "5px">
    <tr>
        <td>
            <code>machine</code>
        </td>
        <td>
            The hardware platform of the host operating system.
        </td>
    </tr>
    <tr>
        <td>
            <code>name</code>
        </td>
        <td>
            The name of the host operating system.
        </td>
    </tr>
    <tr>
        <td>
            <code>release</code>
        </td>
        <td>
            The release of the host operating system.
        </td>
    </tr>
    <tr>
        <td>
            <code>version</code>
        </td>
        <td>
            The version of the host operating system.
        </td>
    </tr>
</table>


<h3>The <code>PCRE</code> module</h3>

This module provides regular expression functions. See the <a href="http://www.pcre.org/pcre.txt">PCRE</a> documentation for the syntax and options that PCRE provides.

<p>Important functions and classes in the <code>PCRE</code> module are as follows:

<p><table cellpadding = "5px">
    <tr>
        <td>
            <code>compile(pattern)</code>
        </td>
        <td>
            Compiles the string <code>pattern</code> and returns a regular expression object.
        </td>
    </tr>
</table>

<p>Regular expression objects support the following methods:

<p><table cellpadding = "5px">
    <tr>
        <td>
            <code>match(s, i := 0)</code>
        </td>
        <td>
            Attempts to match the regular expression against string <code>s</code>. <code>match</code> anchors its match to a particular position <code>i</code> which defaults to <code>0</code>. In other words, if the regular expression does not match at that position, it does not search through the string looking for another position to match at.
            
            <p>If the match succeeds, a match object is returned; otherwise the function fails.
        </td>
    </tr>
</table>

<p>Match objects support the following methods:

<p><table cellpadding = "5px">
    <tr>
        <td>
            <code>lookup(group_num)</code>
        </td>
        <td>
            Returns the slice of the string matched by the group numbered <code>group_num</code>. Groups are specified within a regular expression by use of parentheses, and are numbered starting from 1. Regular expressions have an implicit group 0 which returns the entire string matched by the regular expression.
            
            <p>Note that this effect can also be achieved via the slice notation i.e. <code>match.lookup(<em>X</em>)</code> is equivalent to <code>match[<em>X</em>]</code>.
        </td>
    </tr>
</table>


<h3>The <code>Strings</code> module</h3>

Important functions and classes in the <code>Strings</code> module are as follows:

<p><table cellpadding = "5px">
    <tr>
        <td>
            <code>format(format, *args)</code>
        </td>
        <td>
            Returns a string based on the format string <code>format</code> which is <code>printf</code>-esque in nature and consumes arguments from <code>args</code>. Valid specifiers are <code>%s</code> for strings and <code>%d</code> for numbers.
        </td>
    </tr>
    <tr>
        <td>
            <code>join(list, separator)</code>
        </td>
        <td>
            Concatenates <code>list</code> into a string inserting <code>separator</code> between items.
        </td>
    </tr>
    <tr>
        <td>
            <code>split(str, separator)</code>
        </td>
        <td>
            Splits the string <code>str</code> at each instance of the string <code>separator</code>, returning a list of the split string.
        </td>
    </tr>
</table>


<h3>The <code>Sys</code> module</h3>

Important functions and classes in the <code>Sys</code> module are as follows:

<p><table cellpadding = "5px">
    <tr>
        <td>
            <code>argv</code>
        </td>
        <td>
            A list containing the command line arguments passed to the Converge program.
        </td>
    </tr>
    <tr>
        <td>
            <code>exit(code)</code>
        </td>
        <td>
            Exits the program with exit code <code>code</code> which must be an integer.
        </td>
    </tr>
    <tr>
        <td>
            <code>print(*s)</code>
        </td>
        <td>
            Prints all arguments passed to it to standard out. Strings are printed as is; all other objects have their <code>to_str</code> function called.
        </td>
    </tr>
    <tr>
        <td>
            <code>println(*s)</code>
        </td>
        <td>
            Prints all arguments passed to it to standard out, and then prints a trailing newline. Strings are printed as is; all other objects have their <code>to_str</code> function called.
        </td>
    </tr>
    <tr>
        <td>
            <code>program_path</code>
        </td>
        <td>
            A string containing the path of the current program. NB: This may be set to null (e.g. if the program was loaded from memory), and if present may not be a fully canonicalized path.
        </td>
    </tr>
</table>


<hr>


<h2>The class hierarchy</h2>

Converge follows an ObjVLisp style of classes, metaclasses and objects. Every object is an <em>instance</em> of a particular class. <code>Object</code> is the base class from which all other classes ultimately extend. Some important slots present in all objects are:

<p><table cellpadding = "5px">
    <tr>
        <td>
            <code>instance_of</code>
        </td>
        <td>
            Slot reference to the class which this object instantiated.
        </td>
    </tr>
    <tr>
        <td>
            <code>is_instance(class_)</code>
        </td>
        <td>
            Succeeds if the object is an instance of <code>class_</code> or one of its subclasses.
        </td>
    </tr>
    <tr>
        <td>
            <code>init(*v)</code>
        </td>
        <td>
            Called when a class is instantiated. Does not return a value.
        </td>
    </tr>
    <tr>
        <td>
            <code>to_str()</code>
        </td>
        <td>
            Produces a string representation of the object.
        </td>
    </tr>
    <tr>
        <td>
            <code>dcopy()</code>
        </td>
        <td>
            Returns a 'deep copy' of the object, calling <code>dcopy</code> recursively on all sub-elements [with the exception of the <code>instance_of</code> slot].
        </td>
    </tr>
    <tr>
        <td>
            <code>has_slot(name)</code>
        </td>
        <td>
            Succeeds if the object has a slot <code>name</code>.
        </td>
    </tr>
    <tr>
        <td>
            <code>get_slot(name)</code>
        </td>
        <td>
            Returns the value of the slot <code>name</code>. Throws an exception if <code>name</code> does not exist.
        </td>
    </tr>
    <tr>
        <td>
            <code>set_slot(name, value)</code>
        </td>
        <td>
            Sets the value of the slot <code>name</code> to <code>value</code>.
        </td>
    </tr>
</table>


<h3>Classes and metaclasses</h3>

All classes are instances of <code>Class</code> or one of its subclasses. Thus the classes we have seen earlier in this document have elided the <code>metaclass</code> which defaults to <code>Class</code> 

<pre class="indented-code">
class Animal metaclass Class:
    ...
</pre>

New metaclasses can be defined and used thus:

<pre class="indented-code">
class Singleton(Class):
    func new():
        if not self.has_slot("instance"):
            self.instance := exbi Class.new()
        return self.instance

class M metaclass Singleton:
    ...
</pre>

Sub-classes of <code>Class</code> generally need to override the <code>new</code> method which is invoked when a class is instantiated, and is expected to return a new object.


<hr>


<h2>Compile time meta-programming</h2>

This is the interface which allows Converge programs to 'teach the compiler a certain class of tricks'. It is heavily influenced by Template Haskell, and readers are referred to the <a href="http://www.haskell.org/th/papers/meta-haskell.ps">Peyton-Jones and Sheard</a> paper which documents Template Haskell.

<p>For the time being the best reference for Converge's compile-time meta-programming features is the technical report <a href="http://tratt.net/laurie/research/publications/papers/tratt05convergepl.pdf">The Converge Programming Language</a>.


<hr>


<h2>Memory management</h2>

Converge supports full garbage collection. Users do not need to concern themselves with trivial memory management issues, although as with any such system one should be aware of inadvertently creating long-lived memory cycles which may mean that memory can not be garbage collected.

<!--#include virtual="/footer.inc" -->
