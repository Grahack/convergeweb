<!--#include virtual="/header.inc" -->

<h1>Guide to compile-time meta-programming</h1>

Compile-time meta-programming can be thought of as being equivalent to macros; more formally, it allows the user of a programming language a mechanism to interact with the compiler to allow the construction of arbitrary program fragments by user code. In essence Converge provides a mechanism to allow its concrete syntax to describe abstract syntax trees - conventionally called ITree's in Converge - which can then be then spliced into a source file.


<h2>A first example</h2>

<p>The following program is a simple example of compile-time meta-programming, trivially adopted from its <a href="http://www.swen.uwaterloo.ca/~kczarnec/dagstuhl04.pdf">Template Haskell cousin</a>. <code>expand_power</code> recursively creates an expression that multiplies <code>n</code> <code>x</code> times; <code>mk_power</code> takes a parameter <code>n</code> and creates a function that takes a single argument <code>x</code> and calculates <em>x ^ n</em>; <code>power3</code> is a specific power function which calculates <em>n^3</em>:
<pre>
func expand_power(n, x):
  if n == 0:
    return [| 1 |]
  else:
    return [| ${x} * ${expand_power(n - 1, x)} |]

func mk_power(n):
  return [|
    func (x):
      return ${expand_power(n, [| x |])}
  |]
  
power3 := $&lt;mk_power(3)&gt;
</pre>

<em>Quasi-quoted</em> expressions <code>[| ... |]</code> build ITrees that represent the program code contained within them whilst ensuring that variable references respect Converge's lexical scoping rules. <em>Splice annotations</em> <code>$&lt;...&gt;</code> evaluate the expression within at compile-time (and before VM instruction generation), replacing the splice annotation itself with the AST resulting from its evaluation. This is achieved by creating a temporary module containing the splice expression in a function, compiling the temporary module into bytecode, injecting it into the running VM, and then evaluating the function therein. <em>Insertions</em> <code>${...}</code> are used within quasi-quotes; they evaluate the expression within and copy the resulting ITree into the ITree being generated by the quasi-quote.

<p>When the above example has been compiled into VM instructions, <code>power3</code> essentially looks as follows:
<pre>
power3 := func (x):
  return x * x * x * 1
</pre>

By using the quasi-quotes and splicing mechanisms, we have been able to synthesise at compile-time a function which can efficiently calculate powers without resorting to recursion, or even iteration. As this example highlights, a substantial difference from traditional LISP derived macro schemes is that Converge functions are not explicitly identified as being macros --- they are normal functions that happen to be called at compile-time.


<hr>


<h2>Major features</h2>

The three major features of compile-time meta-programming are splicing, quasi-quoting, and insertion.

<h3>Splicing</h3>

The key part of the <q>powers</q> program is the splice annotation in the line <code>power3 := $&lt;mk_power(3)&gt;</code>. The splice tells the compiler to evaluate the expression between the chevrons at compile-time, and to include the result of that evaluation in the module for ultimate bytecode generation. In order to perform this evaluation, the compiler creates a temporary or <q>dummy</q> module which contains all the necessary definitions up to, but excluding, the definition the splice annotation is a part of; to this temporary module a new splice function (conventionally called <code>$$splice$$</code>) is added which contains a single expression <code>return <em>splice expr</code></em>. This temporary module is compiled to bytecode and injected into the running VM, whereupon the splice function is called. Thus the splice function `sees' all the necessary definitions prior to it in the module, and can call them freely -- there are no other limits on the splice expression. The splice function must return a valid ITree which the compiler uses in place of the splice annotation.

<p>Splice annotations within a file are executed strictly in order from top to bottom, and that splice annotations can not contain splice annotations.


<h3>Quasi-quoting</h3>

Quasi-quotes allow ITree's to be built using Converge's normal concrete syntax. Essentially a quasi-quoted expression evaluates to the ITree which represents the expression inside it. For example, whilst the raw Converge expression <code>4 + 2</code> prints <code>6</code> when evaluated, <code>[| 4 + 2 |]</code> evaluates to an ITree which prints out as <code>4 + 2</code>. Thus the quasi-quote mechanism constructs an ITree directly from the users' input - the exact nature of the ITree is of immaterial to the casual ITree user, who need not know that the resulting ITree is structured along the lines of <em>add(int(4), int(2))</em>.

<p>The quasi-quotes mechanism can be used to express ITree's of single expressions - in which case an individual ITree is returned - or a multiline sequence of expressions - in which case a list of ITree's is returned.

<p>Note that Converge's splicing and quasi-quote mechanisms cancel each other out: <code>$&lt;[| <em>x</em> |]&gt;</code> is equivalent to <code><em>x</em></code> (though not necessarily vice versa if <code><em>x</em></code> does not contain a valid ITree).



<h2>Insertion</h2>

Insertions within quasi-quotes work very differently to splices (which occur outside quasi-quotes): the insertion expression itself does not force compile-time evaluation. Instead the insertion expression is essentially copied as-is into the code that the quasi-quotes transforms to. For example, the quasi-quoted expression <code>[| ${x} + 2 |]</code> leads to an ITree along the lines of <em>add(x, int(2))</em> -- the variable <code>x</code> in this case would need to contain a valid ITree. As this example shows, since splice annotations within quasi-quotes do not cause a change of meta-level, variable references do not cause staging concerns.

<p>This feature completes the cancelling out relationship between splicing and quasi-quoting: <code>[| ${em>x</em} |]</code> is equivalent to <code><em>x</em></code> (though not necessarily vice versa if <code><em>x</em></code> does not contain a valid ITree).


<hr>

<h2>Scoping rules</h2>

Compile-time meta-programming requires additions to Converge's scoping rules.


<h3>Scoping and splicing</h3>

<p>Evaluating a splice expression leads to a new <q>stage</q> in the compiler being executed. Converge's rules about which references can cross the staging boundary are simple: only references to top-level module definitions can be carried across the staging boundary. For example the following code is invalid since the variable <code>x</code> will only have a value at run-time, and hence is unavailable to the splice expression which is evaluated at compile-time:
<pre>
func g(...):
  return ...

func f(x):
  $&lt;g(x)&gt;
</pre>
Note the resulting error message:
<pre>
Error: Line 21, column 3: Unknown variable 'x'
</pre>
might initially seem somewhat confusing, since the user can clearly see <code>x</code>. However it makes rather more sense when one realises that the message is the result of compiling the following temporary module:
<pre>
func g(...):
  return ...

func $$splice$$(...):
  return g(x)
</pre>
Clearly when compiling this, there is no <code>x</code> variable in scope.


<h3>Scoping and quasi-quotes</h3>

The quasi-quote mechanism can be used to surround any Converge expression to allow the easy construction of ITree's. Quasi-quoting an expression has two important properties: it fully respects lexical scoping, and avoids inadvertent variable capture.


<h4>Lexical scoping</h4>

Consider the following contrived example of module <code>A</code>:
<pre>
func x():
  return 4

func y():
  return [| x() * 2 |]
</pre>
and module <code>B</code>:
<pre>
import A, Sys

func x():
  return 2

func main():
  Sys::println($&lt;A::y()&gt;)
</pre>
The quasi-quotes mechanisms ensures that since the reference to <code>x</code> in the quasi-quoted expression in <code>A::y</code> refers lexically to <code>A::x</code>, that running module <code>B</code> prints out <code>8</code>. This example shows one of the reasons why Converge needs to be able to statically determine namespaces: since the reference of <code>x</code> in <code>A.y</code> is lexically resolved to the function <code>A::x</code>, the quasi-quotes mechanism can replace the simple reference with an <em>original name</em> that always evaluates to the slot <code>x</code> within the specific module <code>A</code> wherever it is spliced into, even if <code>A</code> is not in scope (or a different <code>A</code> is in scope) in the splice location.


<h4>Hygiene</h4>

<p>Variable capture is when splicing in an ITree could cause variables with the same name to inadvertantly overwrite (or <q>capture</q>) each other. Consider the following example:
<pre>
func f():
  return [| x := 4 |]

func g():
  x := 10
  $&lt;f()&gt;
  y := x
</pre>
What might one expect the value of <code>y</code> in function <code>g</code> to be after the value of <code>x</code> is assigned to it? A naive splicing of <code>f()</code> into <code>g</code> would mean that the <code>x</code> within <code>[| x := 4 |]</code> would be captured by the <code>x</code> already in <code>g</code> -- <code>y</code> would end with the value <code>4</code>. If this was the case, using the quasi-quote mechanism could potentially cause all sorts of unexpected interactions and problems. In order to solve this problem, not only is Converge able to statically determine namespaces, but variables can be alpha-renamed (essentially meaning that <code>x</code> can be changed consistently to <code>y</code> in a given scope) without affecting the programs semantics. This is a significant deviation from the Python heritage. The quasi-quotes mechanism determines all bound variables in a quasi-quoted expression, and preemptively alpha-renames each bound variable to a name which is invalid in the normal concrete syntax. In so doing, Converge guarantees that the user can not inadvertently cause variable clashes. All references to the variable within the quasi-quotes are updated similarly. Thus the <code>x</code> within <code>[| x := 4 |]</code> will not cause variable capture to occur, and the variable <code>y</code> in function <code>g</code> will be set to <code>10</code>.

<p>There is one exception: top-level definitions (all of which are assignments to a variable, although syntactic sugar generally obscures this fact) can not be alpha-renamed since this could lead to run-time <q>slot missing</q> exceptions being raised. Converge thus does not permit top-level definitions to be alpha-renamed.


<h4>Dynamic scoping</h4>

Sometimes the quasi-quote mechanisms automatic alpha-renaming of variables is not what is needed. For example consider a function <code>swap(x, y)</code> which should swap the values of two variables. In such a case, we <em>want</em> the result of the splice to capture the variables in the spliced environment. The following definition of <code>swap</code> expects to be passed two ITree's representing variables:
<pre>
func swap(x, y):
  return [|
    temp := ${x}
    ${x} := ${y}
    ${y} := temp
  |]
</pre>
It is initially tempting to try and use this function as follows:
<pre>
a := 10
b := 20
$&lt;swap([| a |], [| b |])&gt;
</pre>
However this causes a staging error since the <code>a</code> and <code>b</code> in the quasi-quotes do not refer to a bound variable either inside or outside the quasi-quotes when the splice expression is evaluated (the latter would be invalid anyway, due to Converge's lifting rules; see later}). <code>swap</code> needs to be passed ITree's representing variable names, not references to variables. ITree's representing variable names can be constructed by the idiom <code>CEI::ivar(x)</code> where <code>x</code> is a string representing a variable name. When such a variable name is spliced into a quasi-quotes it will not be renamed, thereby allowing dynamic scoping. A correct call to <code>swap</code> thus looks as follows:
<pre>
$&lt;swap(CEI::ivar(a), CEI::ivar("b"))&gt;
</pre>
In this case, the variable names constructed by the <code>CEI</code> interface are first spliced into the quasi-quotes in the <code>swap</code> function. The resulting ITree from the quasi-quotes is then spliced in place of the <code>swap</code> call, and the variable names dynamically capture the <code>a</code> and <code>b</code> variables.

<p>Dynamic scoping also tends to be useful when a quasi-quoted function is created piecemeal with many separate quasi-quote expressions. In such a case, variable references can only be resolved successfully when all the resulting ITree's are spliced together since references to the function's parameters and so on will not be determined until that point. Since it is highly tedious to continually write <code>CEI::ivar("foo")</code>, Converge provides the special syntax <code>&amp;foo</code> which is equivalent. Notice that this notation prefixes a variable <em>name</em> --- it has nothing to do with the value the variable contains. Using this syntax also allows <code>swap</code> to be called in the following less cumbersome fashion:
<pre>
$&lt;swap([| &amp;a |], [| &amp;b |])&gt;
</pre>


<h4>Forward references and splicing</h4>

We saw earlier that when a splice annotation outside quasi-quotes is encountered, a temporary module is created which contains all the definitions up to, but excluding, the definition holding the splice annotation. This is a very useful feature since compile-time functions used only in one module can be kept in that module. However this introduces a real problem involving forward references (i.e. a reference to a definition defined later in the file). If a splice annotation is encountered and compiles a subset of the module, then some definitions involved in forward references may not be included: thus the temporary module will fail to compile, leading to the entire module not compiling. Worse still, the user is likely to be presented with a highly confusing error telling them that a particular reference is undefined when, as far as they are concerned, the definition is staring at them within their text editor.

<p>Consider the following contrived example:
<pre>
func f1():
  return [| 7 |]

func f2():
  x := f4()

func f3():
  return $&lt;f1()&gt;

func f4():
  pass
</pre>
If <code>f2</code> is included in the temporary module created when evaluating the splice annotation in <code>f3</code>, then the forward reference to <code>f4</code> will be unresolvable.

<p>Converge's solution to this problem is to include only the minimal needed subset of definitions in the temporary module; thus most forward references do not raise a compile-time error. When a splice annotation is encountered, the Converge compiler does not immediately create a temporary module. First it calculates the splice expressions' free variables; any previously encountered definition which has a name in the set of free variables is added to a set of definitions to include. These definitions themselves then have their free variables calculated, and again any previously encountered definition which has a name in the set of free variables is added to the set of definitions to include. This last step is repeated until an iteration adds no new definitions to the set. At this point, Converge then goes back in order over all previously encountered definitions, and if the definition is in the list of definitions to include, it is added to the temporary module (this last stage ensures that definitions are not reordered in the temporary module). Note also that free variables which genuinely do not refer to any definitions (i.e. a mistake on the part of the programmer) will pass through this scheme unmolested and will raise an appropriate error when the temporary module is compiled.

<p>Using this method, the temporary module that is created and evaluated for the example looks as follows:
<pre>
func f1():
  return [| 7 |]

func $$splice$$():
  return f1()
</pre>

There are thus no unresolvable forward references in this example. Notice that Converge's approach to the forward reference problem is not a completely general solution since some forward references (particularly those to definitions beyond a splice site) are inherently unresolvable. Converge's approach is intended to significantly reduce the problem to the point that any unresolvable references are the result of programmer error.


<hr>

<h2>The <code>CEI</code> interface</h2>

At various points when compile-time meta-programming, one needs to interact with the compiler. The Converge compiler is entirely contained within a package called <code>Compiler</code> which is available to every Converge program. The <code>CEI</code> module within the <code>Compiler</code> package is the officially sanctioned interface to the Compiler, and can be imported with <code>import Compiler::CEI</code>. Accessing the compiler internals in any other way may lead to future incompatibilities or undefined behaviour.

<p>The <a href="/documentation/current/modules_html/Compiler.CEI.html">complete CEI module documentation can is available online</a>.


<h3>When quasi-quotes are not enough</h3>

Some ITree's can not practically be created using quasi-quotes. For example an <code>if</code> statement with multiple <code>elif</code> clauses has no obvious concrete syntax equivalent. In such cases the <code>CEI</code> interface presents a more traditional meta-programming interface to the user that allows ITree's that are not expressible via quasi-quotes to be built. Each ITree element has a corresponding function with a lower case name and a prepended `i' in the <code>CEI</code> interface e.g. <code>ivar</code>.


<h3>Names</h3>

We saw earlier that the Converge compiler sometimes uses names for variables that the user can not specify using concrete syntax.

<p>Users can generate their own <q>fresh</q> names - that is names that are guaranteed to clash with other normal or fresh names - using the <code>fresh_name</code> function. This takes an optional argument <code><em>x</em></code> which, if present, is incorporated into the generated name whilst still guaranteeing the uniqueness of the resulting name; this feature aids debugging by allowing the user to trace the origins of a fresh name.

<p>All fresh names begin with <code>$$</code>, and subverting the fresh name interface by manually creating variables beginning with the same prefix leads to undefined behaviour.


<h3>Lifting values</h3>

When meta-programming, one often needs to take a normal Converge value (e.g. a string) and obtain its ITree equivalent: this is known as <em>lifting</em> a value. The <code>lift</code> function in the <code>CEI</code> module lifts built-in datatypes such as strings into their ITree equivalents. Container types such as lists are recursively converted into their ITree equivalent.


<hr>

<h2>A longer example</h2>

This section uses the example of generating a function for a simplified <code>printf</code> style function. This function takes a format string such as <code>"%s has %d %s"</code> and returns a quasi-quoted function which takes an argument per <q>%</q> specifier and intermingles that argument with the main text string. For the purposes of this section, we deal only with decimal numbers <code>%d</code> and strings <code>%s</code>.

<p>This example assumes the existence of a function <code>split_format</code> which given a string such as <code>"%s has %d %s"</code> returns a list of the form <code>[PRINTF_STRING, " has ", PRINTF_INT, " ", PRINTF_STRING]</code> where <code>PRINTF_STRING</code> and <code>PRINTF_INT</code> are constants. The full code can be found for this example, including for <code>split_format</code> can be found in the <code>examples/compile_time</code> directory in the Converge distribution.

<p>First we define the main <code>printf</code> function which creates the appropriate number of parameters for the format string (of the form <code>p0</code>, <code>p1</code> etc.). Parameters must be created by the <code>CEI</code> interface. An <code>iparam</code> has two components: a variable, and a default value (the latter can be set to <code>null</code> to signify the parameter is mandatory and has no default value). <code>printf</code> then returns an anonymous quasi-quoted function which contains the parameters, and a spliced-in expression returned by <code>simple_printf_expr</code>:

<pre>
func simple_printf(format):
  split := split_format(format)

  params := []
  i := 0
  for part := split.iter():
    if part == PRINTF_INT | part == PRINTF_STRING:
      params.append(CEI::iparam(CEI::ivar("p" + i.to_str()), null))
      i += 1

  return [|
    func (${params}):
      return ${simple_printf_expr(split, 0)}
  |]
</pre>

Note the use of an insertion <code>(${params})</code> of a list of parameters into the anonymous function.

<p><code>simple_printf_expr</code> is a recursive function which turns a list such as <code>[PRINTF_INT, ": ", PRINTF_STRING]</code> into an expression along the lines of <code>p0.to_str + ": " + p1</code>:

<pre>
func simple_printf_expr(split, param_i):
  if split.len() == 0:
    return [| "" |]

  param := CEI::ivar("p" + param_i.to_str())
  if Builtins::String.conformed_by(split[0]):
    return [| ${CEI::lift(split[0])} + ${simple_printf_expr(split[1 : ], param_i)} |]
  elif split[0] == PRINTF_INT:
    return [| ${param}.to_str() + ${simple_printf_expr(split[1 : ], param_i + 1)} |]
  elif split[0] == PRINTF_STRING:
    return [| ${param} + ${simple_printf_expr(split[1 : ], param_i + 1)} |]
</pre>

For the input <code>%s has %d %s</code> the following ITree is created:

<pre>
func (p0, p1, p2):
  return p0 + " has " + p1.to_str() + " " + p2 + ""
</pre>

Of course, what we see here is not the ITree itself; rather we see a pretty printed concrete syntax version of the ITree. ITree's can be converted into a string representation with the <code>CEI::itree_format</code> function.


<hr>


<h2>Valid splice and insertion locations</h2>

Splices and inserts can appear at various locations, with different restrictions on what they are expected to return. The valid locations, and expected return types of a splice or insert, are as follows:

<table cellpadding="5px">
<tr style="font-weight: bold">
<td>Location</td>
<td>Example</td>
<td>Description</td>
</tr>

<tr>
<td valign="top">Block-level expression</td>
<td valign="top"><pre>x := ...
$<...>
f(x)</pre></td>
<td valign="top">
A single IExpr, or list of IExpr's, can be spliced or inserted when an insert appears as a block-level expression (i.e. it is not a sub-expression).
</td>
</tr>

<tr>
<td valign="top"><q>Embedded</q> expression</td>
<td valign="top"><pre>x := $<...> + 2</pre></td>
<td valign="top">
An IExpr can be spliced or inserted anywhere a normal expression would be expected.
</td>
</tr>

<tr>
<td valign="top">Top-level definitions</td>
<td valign="top"><pre>import X
$<...>
</pre></td>
<td valign="top">
A single IClass_Def, IFunc_Def, IAssignment, or a list containing objects of these types can be spliced at the top-level of a file (since quasi-quotes can not appear at the top-level of a file, this particular type of splicing does not have an insertion equivalent).
</td>
</tr>

<tr>
<td valign="top">Class fields</td>
<td valign="top"><pre>class C:
  $<...></pre></td>
<td valign="top">
A single IAssignment or IFunc_Def, or a list containing objects of these types, can be spliced or inserted when an insert appears as a class field.
</td>
</tr>


<tr>
<td valign="top">Function name</td>
<td valign="top"><pre>func $<...>(...):
  ...
</pre></td>
<td valign="top">
A string can be spliced or inserted for a function name.
</td>
</tr>

<tr>
<td valign="top">Function parameter(s)</td>
<td valign="top"><pre>func f($<...>):
  ...
</pre></td>
<td valign="top">
A single IParam, or list of IParams, can be spliced or inserted into a functions parameters list.
</td>
</tr>

<tr>
<td valign="top">Module lookup</td>
<td valign="top"><pre>Module::$<...></pre></td>
<td valign="top">
A string can be spliced or inserted for a definition to be looked-up in a module.
</td>
</tr>

<tr>
<td valign="top">Slot lookup</td>
<td valign="top"><pre>o.$<...></pre></td>
<td valign="top">
A string can be spliced or inserted for a slot name to be looked-up in an object.
</td>
</tr>

<tr>
<td valign="top">Assignment target(s)</td>
<td valign="top"><pre>$<...> := ...</pre></td>
<td valign="top">
An IVar, IGet, ISlot_Lookup, or a list containing objects of these types, can be spliced or inserted for the targets of an assignment.
</td>
</tr>
</table>


<hr>


<h2>Src infos</h2>

Src infos are Converge's way of passing around and storing information relating bytecode instructions to the source code location that generated that bytecode. The src info concept is used uniformly throughout the Converge parser, compiler, and VM. A src info is a tuple <code>[&lt;<em>file name</em>&gt;, &lt;<em>char offset</em>&gt;]</code>; src infos are lists of these tuples. The special variable <code>__SRC_INFO__</code> returns src infos that pinpoint the first character of the variable name.

<p>When an ITree is built with quasi-quotes, it automatically picks up the src infos of the file and location of the quasi-quote. Extra src infos can be added using the following syntax:

<pre>[&lt;<em>expr</em>&gt;| ... |]</pre>


<hr>


<h2>DSL blocks</h2>

A DSL can be embedded into a Converge source file via a <em>DSL block</em>. Such a block is introduced by a variant on the splice syntax <code>$&lt;&lt;<em>expr</em>&gt;&gt;</code> where <code><em>expr</em></code> should evaluate to a function (the <em>DSL implementation function</em>). The DSL implementation function is called at compile-time with a string representing the DSL block, and is expected to return an AST which will replace the DSL block in the same way as a normal splice. Compile-time meta-programming is thus the mechanism which facilitates embedding DSLs. Colloquially one uses the DSL implementation function to talk about the DSL block as being `an <em>expr</em> block'.

<p>An example of a DSL block and DSL implementation function is as follows:

<pre>
func dslim(dsl_block, src_infos):
  return ...

$&lt;&lt;dslim&gt;&gt;:
  ...
</pre>

Typically the DSL implementation uses the <a href="/documentation/current/modules_html/Compiler.CEI.html#dsl_parse"><code>CEI::dsl_parse</code></a> convenience function to parse the DSL block.

<!--#include virtual="/footer.inc" -->
